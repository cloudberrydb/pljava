# Release notes

#set($h2 = '##')
#set($h3 = '###')
#set($h4 = '####')
#set($h5 = '#####')
#set($gborgbug = 'http://web.archive.org/web/20061208113236/http://gborg.postgresql.org/project/pljava/bugs/bugupdate.php?')
#set($pgfbug = 'http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=')
#set($pgffeat = 'http://pgfoundry.org/tracker/?func=detail&amp;atid=337&amp;group_id=1000038&amp;aid=')
#set($ghbug = 'https://github.com/tada/pljava/issues/')

$h2 PL/Java 1.5.1

This release chiefly adds support for PostgreSQL 9.6 and 10,
and plays more nicely with `pg_upgrade`. With PostgreSQL 9.6 support
comes the ability to declare functions
`PARALLEL { UNSAFE | RESTRICTED | SAFE }`, and with PG 10 support,
transition tables are available to triggers.

$h3 Security

1.5.1 removes the code at issue in [CVE-2016-0768][], which pertained to
PostgreSQL large objects, but had never been documented or exposed as API.

This is not expected to break any existing code at all, based on further
review showing the code in question had also been simply broken, since 2006,
with no reported issues in that time. That discovery would support an argument
for downgrading the severity of the reported vulnerability, but with no need
to keep that code around, it is more satisfying to remove it entirely.

Developers wishing to manipulate large objects in PL/Java are able to do so
using the SPI JDBC interface and the large-object SQL functions already
available in every PostgreSQL version PL/Java currently supports.

$h3 Changes

$h4 PostgreSQL 9.6 and parallel query

A function in PL/Java can now be [annotated][apianno]
`parallel={UNSAFE | RESTRICTED | SAFE}`, with `UNSAFE` the default.
A new [user guide section][ugparqry] explains the possibilities and
tradeoffs. (Good cases for marking a PL/Java function `SAFE` may be
rare, as pushing such a function into multiple background processes
will require them all to start JVMs. But if a practical application
arises, PostgreSQL's `parallel_setup_cost` can be tuned to help the
planner make good plans.)

Although `RESTRICTED` and `SAFE` Java functions work in simple tests,
there has been no exhaustive audit of the code to ensure that PL/Java's
internal workings never violate the behavior constraints on such functions.
The support should be considered experimental, and could be a fruitful
area for beta testing.

[ugparqry]: use/parallel.html

$h4 Tuple counts widened to 64 bits with PostgreSQL 9.6

To accommodate the possibility of more than two billion tuples in a single
operation, the SPI implementation of the JDBC `Statement` interface now
provides the JDK 8-specified `executeLargeBatch` and `getLargeUpdateCount`
methods defined to return `long` counts. The original `executeBatch` and
`getUpdateCount` methods remain but, obviously, cannot return counts that
exceed `INT_MAX`. In case the count is too large, `getUpdateCount` will throw
an `ArithmeticException`; `executeBatch` will store `SUCCESS_NO_INFO` for
any statement in the batch that affected too many tuples to report.

For now, a `ResultSetProvider` cannot be used to return more than `INT_MAX`
tuples, but will check that condition and throw an error to ensure predictable
behavior.

$h4 `pg_upgrade`

PL/Java should be upgraded to 1.5.1 in a database cluster, before that
cluster is binary-upgraded to a newer PostgreSQL version using `pg_upgrade`.
A new [Upgrading][upgrading] installation-guide section centralizes information
on both upgrading PL/Java in a database, and upgrading a database with PL/Java
in it.

[upgrading]: install/upgrade.html

$h4 Suppressing row operations from triggers

In PostgreSQL, a `BEFORE ROW` trigger is able to allow the proposed row
operation, allow it with modified values, or silently suppress the operation
for that row. Way back in PL/Java 1.1.0, the way to produce the 'suppress'
outcome was for the trigger method to throw an exception. Since PL/Java 1.2.0,
however, an exception thrown in a trigger method is used to signal an error
to PostgreSQL, and there has not been a way to suppress the row operation.

The `TriggerData` interface now has a [`suppress`][tgsuppress] method that
the trigger can invoke to suppress the operation for the row.

[tgsuppress]: pljava-api/apidocs/index.html?org/postgresql/pljava/TriggerData.html#suppress()

$h4 Constraint triggers

New attributes in the `@Trigger` annotation allow the SQL generator to
create constraint triggers (a type of trigger that can be created with SQL
since PostgreSQL 9.1). Such triggers will be delivered by the PL/Java runtime
(to indicate that a constraint would be violated, a constraint trigger
method should throw an informative exception). However, the trigger method
will have access, through the `TriggerData` interface, only to the properties
common to ordinary triggers; methods on that interface to retrieve properties
specific to constraint triggers have not been added for this release.

$h4 PostgreSQL 10 and trigger transition tables

A trigger [annotation][apianno] can now specify `tableOld="`_name1_`"` or
`tableNew="`_name2_`"`, or both, and the PL/Java function servicing the
trigger can do SPI JDBC queries and see the transition table(s) under the
given name(s). The [triggers example code][extrig] has been extended with
a demonstration.

[extrig]: $project.scm.url/pljava-examples/src/main/java/org/postgresql/pljava/example/annotation/Triggers.java

$h4 Logging from Java

The way the Java logging system has historically been plumbed to PostgreSQL's,
as described in [issue 125](${ghbug}125), can be perplexing both because it
is unaffected by later changes to the PostgreSQL settings after PL/Java is
loaded in the session, and because it has honored only `log_min_messages`
and ignored `client_min_messages`. The second part is easy to fix, so in
1.5.1 the threshold where Java discards messages on the fast path is
determined by the finer of `log_min_messages` and `client_min_messages`.

$h4 Conveniences for downstream package maintainers

The `mvn` command to build PL/Java will now accept an option to provide
a useful default for `pljava.libjvm_location`, when building a package for
a particular software environment where the likely path to Java is known.

The `mvn` command will also accept an option to specify, by the path to
the `pg_config` executable, the PostgreSQL version to build against, in
case multiple versions exist on the build host. This was already possible
by manipulating `PATH` ahead of running `mvn`, but the option makes it more
explicit.

A new [packaging section][packaging] in the build guide documents those
and a number of considerations for making a PL/Java package.

[packaging]: build/package.html

$h3 Bugs fixed

$h4 Since 1.5.1-BETA1

* [PostgreSQL 10: SPI_modifytuple failed with SPI_ERROR_UNCONNECTED](${ghbug}134)
* [SPIConnection prepareStatement doesn't recognize all parameters](${ghbug}136)
* [Annotations don't support CREATE CONSTRAINT TRIGGER](${ghbug}138)
* [Ordinary (non-constraint) trigger has no way to suppress operation](${ghbug}142)

$h4 In 1.5.1-BETA1

* [Add support for PostgreSQL 9.6](${ghbug}108)
* [Clarify documentation of ResultSetProvider](${ghbug}115)
* [`pg_upgrade` (upgrade failure from 9.5 to 9.6)](${ghbug}117)
* [Java logging should honor `client_min_messages` too](${ghbug}125)

$h3 Updated PostgreSQL APIs tracked

* `heap_form_tuple`
* 64-bit `SPI_processed`
* 64-bit `Portal->portalPos`
* 64-bit `FuncCallContext.call_cntr`
* 64-bit `SPITupleTable.alloced` and `.free`
* `IsBackgroundWorker`
* `IsBinaryUpgrade`
* `SPI_register_trigger_data`
* `SPI` without `SPI_push`/`SPI_pop`
* `AllocSetContextCreate`

$h2 Earlier releases

## A nice thing about using Velocity is that each release can be entered at
## birth using h2 as its main heading, h3 and below within ... and then, when
## it is moved under 'earlier releases', just define those variables to be
## one heading level finer. Here goes:
#set($h2 = '###')
#set($h3 = '####')
#set($h4 = '#####')
#set($h5 = '######')

$h2 PL/Java 1.5.0

This, the first PL/Java numbered release since 1.4.3 in 2011, combines
compatibility with the latest PostgreSQL and Java versions with modernized
build and installation procedures, automatic generation of SQL deployment
code from Java annotations, and many significant fixes.

$h3 Security

Several security issues are addressed in this release. Sites already
using PL/Java are encouraged to update to 1.5.0. For several of the
issues below, practical measures are described to mitigate risk until
an update can be completed.

[CVE-2016-0766][], a privilege escalation requiring an authenticated
PostgreSQL connection, is closed by installing PL/Java 1.5.0 (including
prereleases) or by updating PostgreSQL itself to at least 9.5.1, 9.4.6,
9.3.11, 9.2.15, 9.1.20. Vulnerable systems are only those running both
an older PL/Java and an older PostgreSQL.

[CVE-2016-0767][], in which an authenticated PostgreSQL user with USAGE
permission on the `public` schema may alter the `public` schema classpath,
is closed by release 1.5.0 (including prereleases). If updating to 1.5.0
must be delayed, risk can be mitigated by revoking public `EXECUTE` permission
on `sqlj.set_classpath` and granting it selectively to responsible users or
roles.

This release brings a policy change to a more secure-by-default posture,
where the ability to create functions in `LANGUAGE java` is no longer
automatically granted to `public`, but can be selectively granted to roles
that will have that responsibility. The change reduces exposure to a known
issue present in 1.5.0 and earlier versions, that will be closed in a future
release ([CVE-2016-0768][], see **large objects, access control** below).

The new policy will be applied in a new installation; permissions will not
be changed in an upgrade, but any site can move to this policy, even before
updating to 1.5.0, with `REVOKE USAGE ON LANGUAGE java FROM public;` followed by
explicit `GRANT` commands for the users/roles expected to create Java
functions.

[CVE-2016-2192][], in which an authenticated user can alter type mappings
without owning the types involved. Exploitability is limited by other
permissions, but if type mapping is a feature being used at a site, one
can interfere with proper operation of code that relies on it. A mitigation
is simply to `REVOKE EXECUTE ... FROM PUBLIC` on the `sqlj.add_type_mapping`
and `sqlj.drop_type_mapping` functions, and grant the privilege only to
selected users or roles. As of 1.5.0, these functions require the invoker
to be superuser or own the type being mapped.

[CVE-2016-0766]: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0766
[CVE-2016-0767]: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0767
[CVE-2016-0768]: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0768
[CVE-2016-2192]: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-2192

$h3 Version compatibility

PL/Java 1.5.0 can be built against recent PostgreSQL versions including 9.5,
using Java SE 8, 7, or 6. See [version compatibility][versions] for more
detail. OpenJDK is well supported. Support for GCJ has been dropped; features
of modern Java VMs that are useful to minimize footprint and startup time,
such as class-data sharing, are now more deeply covered
[in the installation docs][vmopts].

[versions]: build/versions.html
[vmopts]: install/vmoptions.html

$h3 Build procedures

Since 2013, PL/Java has been hosted [on GitHub][ghpljava] and built
using [Apache Maven][mvn]. See the new [build instructions][bld] for details.

Reported build issues for specific platforms have been resolved,
with new platform-specific build documentation
for [OS X][osxbld], [Solaris][solbld], [Ubuntu][ububld],
[Windows MSVC][msvcbld], and [Windows MinGW-w64][mgwbld].

The build produces a redistributable installation archive usable with
the version of PostgreSQL built against and the same operating system,
architecture, and linker. The type of archive is `jar` on all platforms, as
all PL/Java installations will have Java available.

[ghpljava]: https://github.com/tada/pljava
[mvn]: http://maven.apache.org/
[bld]: build/build.html
[msvcbld]: build/buildmsvc.html
[mgwbld]: build/mingw64.html
[osxbld]: build/macosx.html
[solbld]: build/solaris.html
[ububld]: build/ubuntu.html

$h3 Installation procedures

The jar produced by the build is executable and will self-extract,
consulting `pg_config` on the destination system to find the correct
default locations for the extracted files. Any location can be overridden.
(Enhancement requests [6][gh6], [9][gh9])

PL/Java now uses a PostgreSQL configuration variable, `pljava.libjvm_location`,
to find the Java runtime to use, eliminating the past need for highly
platform-specific tricks like link-time options or runtime-loader configuration
just so that PL/Java could find Java. PostgreSQL configuration variables are
now the only form of configuration needed for PL/Java, and the `libjvm_location`
should be the only setting needed if file locations have not been overridden.

In PostgreSQL 9.1 and later, PL/Java can be installed with
`CREATE EXTENSION pljava`. Regardless of PostgreSQL version, installation
has been simplified. Former procedures involving `Deployer` or `install.sql`
are no longer required. Details are in the [new installation instructions][ins].

$h4 Schema migration

The tables used internally by PL/Java have changed. If PL/Java 1.5.0 is
loaded in a database with an existing `sqlj` schema populated by an earlier
PL/Java version (1.3.0 or later), the structure will be updated without data
loss (enhancement request [12][gh12]). *Remember that PL/Java runs independently
in each database session where it is in use. Older PL/Java versions active in
other sessions can be disrupted by the schema change.*

A trial installation of PL/Java 1.5.0 can be done in a transaction, and
rolled back if desired, leaving the schema as it was. Any concurrent sessions
with active older PL/Java versions will not be disrupted by the altered schema
as long as the transaction remains open, *but they may block for the duration,
so such a test transaction should be kept short*.

[ins]: install/install.html

$h3 Changes

$h4 Behavior of `readSQL` and `writeSQL` for base and mirror user-defined types

In the course of fixing [issue #98][gh98], the actual behavior of
`readSQL` and `writeSQL` with base or mirror types, which had not
previously been documented, [now is](develop/coercion.html), along with
other details of PL/Java's type coercion rules found only in the code.
Because machine byte order was responsible for issue #98, it now (a) is
selectable, and (b) has different, appropriate, defaults for mirror UDTs
(which need to match PostgreSQL's order) and for base UDTs (which must
stay big-endian because of how binary `COPY` is specified).
A [new documentation section](use/byteorder.html) explains in detail.

$h4 `USAGE` to `PUBLIC` no longer default for `java` language

Of the two languages installed by PL/Java, functions that declare
`LANGUAGE javau` can be created only by superusers, while those that
declare `LANGUAGE java` can be created by any user or role granted the
`USAGE` privilege on the language.

In the past, the language `java` has been created with PostgreSQL's
default permission granting `USAGE` to `PUBLIC`, but PL/Java 1.5.0
leaves the permission to be explicitly granted to those users or roles
expected to create Java functions, in keeping with least-privilege
principles. See **large objects, access control** under **known issues**
for background.

$h4 SQL generated by Java annotations

Java code developed for use by PL/Java can carry in-code annotations,
used by the Java compiler to generate the SQL commands to declare the
new functions, types, triggers, etc. in PostgreSQL (enhancement request
[1011112][], though different in implementation). This eliminates the need
to have Java code and the corresponding SQL commands developed in parallel,
and the class of errors possible when both are not updated together. It
also allows compile-time checks that the Java methods or classes being
annotated are suitable (correct access modifiers, signatures, etc.)
for their declared SQL purposes, rather than discovering
such issues only upon loading the code into PostgreSQL and trying to use it.

The Java compiler writes the generated SQL into a "deployment descriptor"
file (`pljava.ddr` by default), as specified by the SQL/JRT standard. The
file can be included in a `jar` archive with the compiled code, and the
commands will be executed by PL/Java when the `install_jar` function is
used to load the jar.

SQL generation is covered in the [updated user documentation][user],
and illustrated in the [Hello, World example][hello] and
[several other supplied examples][exanno]. Reference information
is [in the API documentation][apianno]. It is currently usable to declare
functions, triggers, and user-defined types, both base and composite.

[user]: use/use.html
[hello]: use/hello.html
[exanno]: $project.scm.url/pljava-examples/src/main/java/org/postgresql/pljava/example/annotation
[apianno]: pljava-api/apidocs/index.html?org/postgresql/pljava/annotation/package-summary.html#package_description

The history of this feature in PL/Java is long, with the first related commits
appearing in 2005, six years in advance of an enhancement request for it.
It became generally usable in 2013 when building with
Java SE 6 or later, using the annotation processing framework Java introduced
in that release. 1.5.0 is the first PL/Java numbered release to feature it.

$h5 Annotation keyword changes

If you have been using the SQL generation feature in prerelease `git` builds of
2013 or later, be aware that some annotation keywords have changed in finalizing
the 1.5.0 release. Java code that was compiled using the earlier keywords will
continue to work, but will have to be updated before it can be recompiled.

* For functions: `effects=(VOLATILE,STABLE,IMMUTABLE)` was formerly `type=`
* For functions: `type=` (_an explicit SQL return type for the function_)
    was formerly `complexType=`
* For functions: `trust=(SANDBOXED,UNSANDBOXED)` was formerly
    `(RESTRICTED,UNRESTRICTED)`
* For triggers: `called=(BEFORE,AFTER,INSTEAD_OF)` was formerly `when=`
    and conflicted with the `WHEN` clause introduced for triggers
    in PostgreSQL 9.0.

$h4 A jar may have more than one deployment descriptor

PL/Java formerly allowed only one entry in a jar to be a deployment
descriptor (that is, a file of SQL commands to be executed upon loading
or unloading the jar). The SQL/JRT standard allows multiple entries to
be deployment descriptors, executed in the order they are mentioned
_in the jar manifest_, or the reverse of that order when the jar is
being unloaded. PL/Java now conforms to the standard.

The behavior is useful during transition to annotation-driven deployment
descriptor generation for a project that already has a manually-maintained
deployment descriptor. PL/Java's own `pljava-examples` project is an
illustration, in the midst of such a transition itself.

Note the significance placed by SQL/JRT on the order of entries in a jar
manifest, whose order is normally _not_ significant according to the Jar File
Specification. Care can be needed when manipulating manifests with automated
tools that may not preserve order.

$h4 Conditional execution within deployment descriptors

Deployment descriptors have a primitive conditional-execution provision
defined in the SQL/JRT standard: commands wrapped in a  
`BEGIN IMPLEMENTOR ` _identifier_ construct will only be executed if the
_identifier_ is recognized by the SQL/JRT implementation in use. The design
makes possible jars that can be installed on different database systems that
provide SQL/JRT features, with database-specific commands wrapped in
`BEGIN IMPLEMENTOR` blocks with an _identifier_ specific to the system.
By default, PL/Java recognizes the _identifier_ `postgresql` (matched without
regard to case).

PL/Java extends the standard by allowing the PostgreSQL configuration
variable `pljava.implementors` to contain a list of identifiers that will
be recognized. SQL code in a deployment descriptor can conditionally add
or remove identifiers in this list to influence which subsequent implementor
blocks will be executed, giving a still-primitive but more general control
structure.

In sufficiently recent PostgreSQL versions, the same effect could be
achieved using `DO` statements and PL/pgSQL control structures, but this
facility in PL/Java does not require either to be available.

$h4 Interaction with `SET ROLE` corrected

PL/Java formerly was aware of the user ID associated with the running
session, but not any role ID that user may have acquired with `SET ROLE`.
The result would commonly be failed permission checks made by PL/Java when
the session user did not have the needed permission, but had `SET ROLE` to
a role that did. Likewise, within `install_jar`, PL/Java would execute
deployment descriptor commands as the original session user rather than
as the user's current role, with permission failures a likely result.

Correcting this issue has changed the PL/Java API, but without a bump
of major version because the prior API, while deprecated, is still available.

* [`getOuterUserName`][goun] and [`executeAsOuterUser`][eaou] are new, and
    correctly refer to the session user or current role, when active.
* [`getSessionUserName`][gsun] and [`executeAsSessionUser`][easu] are still
    present but deprecated, and _their semantics are changed_. They are now
    deprecated aliases for the corresponding new methods, which honor the
    set role. Use cases that genuinely need to refer only to the _session_ user
    and ignore the role should be rare, and should be discussed on the mailing
    list or opened as issues.

#set($sessapi = 'pljava-api/apidocs/index.html?org/postgresql/pljava/Session.html#')

[goun]: ${sessapi}getOuterUserName()
[eaou]: ${sessapi}executeAsOuterUser(java.sql.Connection,java.lang.String)
[gsun]: ${sessapi}getSessionUserName()
[easu]: ${sessapi}executeAsSessionUser(java.sql.Connection,java.lang.String)

$h4 Unicode transparency

Since the resolution of [bug 21][gh21], PL/Java contains a regression test
to ensure that character strings passed and returned between PostgreSQL and
Java will round-trip without alteration for the full range of Unicode
characters, _when the database encoding is set to `UTF8`_.

More considerations apply when the database encoding is anything other
than `UTF8`, and especially when it is `SQL_ASCII`. Please see
[character encoding support][charsets] for more.

[charsets]: use/charsets.html

$h3 Enhancement requests addressed

* [Use Annotations instead of DDL Manifest][1011112]
* [Installation of pljava on postgresql servers][gh9]
* [Find an alternative way to install the pljava.so in `/usr/lib`][gh6]
* [Provide database migration][gh12]
* [Support types with type modifiers][1011140] (partial: see [example][typmex])
* [Build process: accommodate Solaris 10][gh102]

[1011112]: ${pgffeat}1011112
[1011140]: ${pgffeat}1011140
[gh9]: ${ghbug}9
[gh6]: ${ghbug}6
[gh12]: ${ghbug}12
[gh102]: ${ghbug}102

[typmex]: $project.scm.url/pljava-examples/src/main/java/org/postgresql/pljava/example/annotation/IntWithMod.java

$h3 Bugs fixed

$h4 Since 1.5.0-BETA3

* [Build process: accept variation in PostgreSQL version string][gh101]
* [Build process: accommodate PostgreSQL built with private libraries][gh103]
* Clarified message when `CREATE EXTENSION` fails because new session needed
* Reduced stack usage in SQL generator
    (small-memory build no longer needs `-Xss`)

$h4 In 1.5.0-BETA3

* [Bogus mirror-UDT values on little-endian hardware][gh98]
* [Base UDT not registered if first access isn't in/out/send/recv][gh99]
* `TupleDesc` leak warnings with composite UDTs
* also added regression test from [1010962][] report

$h4 In 1.5.0-BETA2

* [Generate SQL for trigger function with no parameters][gh92]
* [openssl/ssl.h needed on osx el-capitan (latest 10.11.3)/postgres 9.5][gh94]
    (documented)
* [Source location missing for some annotation errors][gh95]
* [OS X El Capitan "Java 6" dialog when loading ... Java 8][gh96]
* pljava-api jar missing from installation jar

$h4 In 1.5.0-BETA1

* [SPIPreparedStatement.setObject() fails with Types.BIT][1011119]
* [SSLSocketFactory throws IOException on Linux][1011095]
* [PL/Java fails to compile with -Werror=format-security][1011181]
* [PL/Java does not build on POWER 7][1011197]
* [The built in functions do not use the correct error codes][1011206]
* [TupleDesc reference leak][1010962]
* [String conversion to enum fails][gh4]
* [segfault if SETOF RECORD-returning function used without AS at callsite][gh7]
* [pl/java PG9.3 Issue][gh17]
* [No-arg functions unusable: "To many parameters - expected 0"][gh8]
* [Exceptions in static initializers are masked][gh54]
* [UDT in varlena form breaks if length > 32767][gh52]
* [PL/Java kills unicode?][gh21]
* [Type.c expects pre-8.3 find_coercion_pathway behavior][gh65]
* [Support PostgreSQL 9.5][gh48]
* [pl/java getting a build on MacOSX - PostgreSQL 9.3.2][gh22]
* [build pljava on windows for PostgreSQL 9.2][gh23]
* [Error while installing PL/Java with Postgresql 9.3.4 64 bit on Windows 7 64 bit System][gh28]
* [pljava does not compile on mac osx ver 10.11.1 and postgres 9.4][gh63]
* [pljava does not compile on centos 6.5 and postgres 9.4][gh64]
* [Error installing pljava with Windows 7 64 Bit and Postgres 9.4][gh71]
## JNI_getIntArrayRegion instead of JNI_getShortArrayRegion
## Eclipse IDE artifacts
## Site
## Warnings
## Javadoc

[1011119]: ${pgfbug}1011119
[1011095]: ${pgfbug}1011095
[1011181]: ${pgfbug}1011181
[1011197]: ${pgfbug}1011197
[1011206]: ${pgfbug}1011206
[1010962]: ${pgfbug}1010962
[gh4]: ${ghbug}4
[gh7]: ${ghbug}7
[gh8]: ${ghbug}8
[gh17]: ${ghbug}17
[gh54]: ${ghbug}54
[gh52]: ${ghbug}52
[gh21]: ${ghbug}21
[gh65]: ${ghbug}65
[gh48]: ${ghbug}48
[gh22]: ${ghbug}22
[gh23]: ${ghbug}23
[gh28]: ${ghbug}28
[gh63]: ${ghbug}63
[gh64]: ${ghbug}64
[gh71]: ${ghbug}71
[gh92]: ${ghbug}92
[gh94]: ${ghbug}94
[gh95]: ${ghbug}95
[gh96]: ${ghbug}96
[gh98]: ${ghbug}98
[gh99]: ${ghbug}99
[gh101]: ${ghbug}101
[gh103]: ${ghbug}103

$h3 Updated PostgreSQL APIs tracked

Several APIs within PostgreSQL itself have been added or changed;
PL/Java now uses the current versions of these where appropriate:

* `find_coercion_pathway`
* `set_stack_base`
* `GetOuterUserId`
* `GetUserNameFromId`
* `GetUserIdAndSecContext`
* `pg_attribute_*`
* Large objects: truncate, and 64-bit offsets

$h3 Known issues and areas for future work

$h4 Developments in PostgreSQL not yet covered

Large objects, access control
: PL/Java does not yet expose PostgreSQL large objects with a documented,
    stable API, and the support it does contain was developed against pre-9.0
    PostgreSQL versions, where no access control applied to large objects and
    any object could be accessed by any database user. PL/Java's behavior is
    proper for PostgreSQL before 9.0, but improper on 9.0+ where it would be
    expected to honor access controls on large objects ([CVE-2016-0768][]).
    This will be corrected in a future release. For this and earlier releases,
    the recommendation is to selectively grant `USAGE` on the `java` language to
    specific users or roles responsible for creating Java functions; see
    "default `USAGE` permssion" under Changes.

`INSTEAD OF` triggers, triggers on `TRUNCATE`
: These are supported by annotations and the SQL generator, and the runtime
    will deliver them to the specified method, but the `TriggerData` interface
    has no new methods to recognize these cases (that is, no added
    methods analogous to `isFiredAfter`, `isFiredByDelete`). For a method
    expressly coded to be a `TRUNCATE` trigger or an `INSTEAD OF` trigger,
    that is not a problem, but care should be taken when coding a trigger
    method to handle more than one type of trigger, or creating triggers of
    these new types that call a method developed pre-PL/Java-1.5.0. Such a
    method could be called with a `TriggerData` argument whose existing
    `isFired...` methods all return `false`, likely to put the method on an
    unexpected code path.

    A later PL/Java version should introduce trigger interfaces that better
    support such evolution of PostgreSQL in a type-safe way.

Constraint triggers
: Constraint trigger syntax is not supported by annotations and the SQL
    generator. If declared (using hand-written SQL), they will be delivered
    by the runtime, but without any constraint-trigger-specific information
    available to the called method.

Event triggers
: Event triggers are not yet supported by annotations or the SQL generator,
    and will not be delivered by the PL/Java runtime.

Range types
: No predefined mappings for range types are provided.

`PRE_PREPARE`, `PRE_COMMIT`, `PARALLEL_ABORT`, `PARALLEL_PRE_COMMIT`, and `PARALLEL_COMMIT` transaction callbacks, `PRE_COMMIT` subtransaction callbacks
: Listeners for these events cannot be registered and the events will not
    be delivered.

$h4 Imperfect integration with PostgreSQL dependency tracking

In a dump/restore, manual intervention can be needed if the users/roles
recorded as owners of jars are missing or have been renamed. A current
[thread on `pgsql-hackers`][ownhack] should yield a better solution for
a future release.

[ownhack]: http://www.postgresql.org/message-id/56783412.6090005@anastigmatix.net

$h4 Quirk if deployment descriptor loads classes from same jar

The `install_jar` function installs a jar, optionally reading deployment
descriptors from the jar and executing the install actions they contain.
It is possible for those actions to load classes from the jar just installed.
(This would be unlikely if the install actions are limited to typical setup,
function/operator/datatype creation, but likely, if the install actions also
include basic function tests, or if the setup requirements are more
interesting.)

If, for any class in the jar, the first attempt to load that class is made
while resolving a function declared `STABLE` or `IMMUTABLE`, a
`ClassNotFoundException` results. The cause is PostgreSQL's normal treatment of
a `STABLE` or `IMMUTABLE` function, which relies on a snapshot from the start of
the `install_jar` query, when the jar was not yet installed. A workaround is to
ensure that the install actions cause each needed class to be loaded, such as
by calling a `VOLATILE` function it supplies, before calling one that is
`STABLE` or `IMMUTABLE`. (One could even write install actions to declare a
needed function `VOLATILE` before the first call and then redeclare it.)

This issue should be resolved as part of a broader rework of class loading
in a future PL/Java release.

$h4 Partial implementation of JDBC 4 and later

The changes to make PL/Java build under Java SE 6 and later, with version 4.0
and later of JDBC, involved providing the specified methods so
compilation would succeed, with real implementations for some, but for others
only stub versions that throw `SQLFeatureNotSupportedException` if used.
Regrettably, there is nothing in the documentation indicating which methods
have real implementations and which do not; to create such a list would require
an audit of that code. If a method throws the exception when you call it, it's
one of the unimplemented ones.

Individual methods may be fleshed out with implementations as use cases arise
that demand them, but for a long-term roadmap, it seems more promising to
reduce the overhead of maintaining another JDBC implementation by sharing
code with `pgjdbc`, as has been [discussed on pljava-dev][jdbcinherit].

[jdbcinherit]: http://lists.pgfoundry.org/pipermail/pljava-dev/2015/002370.html

$h4 Exception handling and logging

PL/Java does interconvert between PostgreSQL and Java exceptions, but with
some loss of fidelity in the two directions. PL/Java code has some access
to most fields of a PostgreSQL error data structure, but only through
internal PL/Java API that is not expected to remain usable, and code written
for PL/Java has never quite had first-class standing in its ability to
_generate_ exceptions as information-rich as those from PostgreSQL itself.

PL/Java in some cases generates the _categorized `SQLException`s_ introduced
with JDBC 4.0, and in other cases does not.

This area may see considerable change in a future release.
[Thoughts on logging][tol] is a preview of some of the considerations.

[tol]: https://github.com/tada/pljava/wiki/Thoughts-on-logging

$h4 Types with type modifiers and `COPY`

Although it is possible to create a PL/Java user-defined type that accepts
a type modifier (see the [example][typmex]), such a type will not yet be
handled by SQL `COPY` or any other operation that requires the `input` or
`receive` function to handle the modifier. This is left for a future release.

$h3 Credits

PL/Java 1.5.0 owes its being to original creator Thomas Hallgren and
many contributors:

Daniel Blanch Bataller,
Peter Brewer,
Frank Broda,
Chapman Flack,
Marty Frasier,
Bear Giles,
Christian Hammers,
Hal Hildebrand,
Robert M. Lefkowitz,
Eugenie V. Lyzenko,
Dos Moonen,
Asif Naeem,
Kenneth Olson,
Johann Oskarsson,
Thomas G. Peters,
Srivatsan Ramanujam,
Igal Sapir,
Jeff Shaw,
Rakesh Vidyadharan,
`grunjol`,
`mc-soi`.

Periods in PL/Java's development have been sponsored by EnterpriseDB.

In the 1.5.0 release cycle, multiple iterations of testing effort
have been generously contributed by Kilobe Systems and by Pegasystems, Inc.

$h2 Earlier releases

$h3 PL/Java 1.4.3 (15 September 2011)

Notable changes in this release:

* Works with PostgreSQL 9.1
* Correctly links against IBM Java.
* Reads microseconds correctly in timestamps.

Bugs fixed:

* [Be clear about not building with JDK 1.6][1010660]
* [Does not link with IBM VM][1010970]
* [SPIConnection.getMetaData() is incorrectly documented][1010971]
* [PL/Java 1.4.2 Does not build with x86_64-w64-mingw32][1011025]
* [PL/Java does not build with PostgreSQL 9.1][1011091]

Feature Requests:

* [Allow pg_config to be set externally to the Makefile][1011092]
* [Add option to have pljava.so built with the runtime path of libjvm.so][1010955]

[1010660]: ${pgfbug}1010660
[1010970]: ${pgfbug}1010970
[1010971]: ${pgfbug}1010971
[1011025]: ${pgfbug}1011025
[1011091]: ${pgfbug}1011091

[1011092]: ${pgffeat}1011092
[1010955]: ${pgffeat}1010955

$h3 PL/Java 1.4.2 (11 December 2010)

Bugfixes:

* [Function returning complex objects with POD arrays cause a segfault][1010956]
* [Segfault when assigning an array to ResultSet column][1010953]
* [Embedded array support in returned complex objects][1010482]

[1010956]: ${pgfbug}1010956
[1010953]: ${pgfbug}1010953
[1010482]: ${pgfbug}1010482

$h3 PL/Java 1.4.1 (9 December 2010)

Note: Does not compile with Java 6.  Use JDK 1.5 or 1.4.

Compiles with PostgreSQL 8.4 and 9.0.

Connection.getCatalog() has been implemented.

Bugfixes:

* [Compiling error with postgresql 8.4.1][1010759]
* [org.postgresql.pljava.internal.Portal leak][1010712]
* [build java code with debugging if server has debugging enabled][1010189]
* [Connection.getCatalog() returns null][1010653]
* [VM crash in TransactionListener][1010462]
* [Link against wrong library when compiling amd64 code on Solaris][1010954]

[1010759]: ${pgfbug}1010759
[1010712]: ${pgfbug}1010712
[1010189]: ${pgfbug}1010189
[1010653]: ${pgfbug}1010653
[1010462]: ${pgfbug}1010462
[1010954]: ${pgfbug}1010954

Other commits:

For a multi-threaded pljava function we need to adjust stack_base_ptr
before calling into the backend to avoid stack depth limit exceeded
errors.  Previously this was done only on query execution, but we need
to do it on iteration of the ResultSet as well.

When creating a variable length data type, the code was directly
assigning the varlena header length rather than going through an
access macro.  The header format changed for the 8.3 release and this
manual coding was not noticed and changed accordingly.  Use
SET_VARSIZE to do this correctly.

Handle passed by value data types by reading and writing directly to
the Datum rather than dereferencing it.

If the call to a type output function is the first pljava call in a
session, we get a crash.  The first pljava call results in a SPI
connection being established and torn down.  The type output function
was allocating the result in the SPI memory context which gets
destroyed prior to returning the data to the caller.  Allocate the
result in the correct context to survive function exit.

Clean up a warning about byteasend and bytearecv not having a
prototype when building against 9.0 as those declarations are now in a
new header file.


$h3 PL/Java 1.4.0 (1 February 2008)

Warning! The recent postgresql security releases changed the API of a function
that PL/Java uses. The source can be built against either version, but the
binaries will only run against the version they were built against. The PL/Java
binaries for 1.4.0 have all been built against the latest server releases (which
you should be using anyway). If you are using an older you will have to build
from source. The binary releases support: 8.3 - All versions. 8.2 - 8.2.6 and
up. 8.1 - 8.1.11 and up. 8.0 - 8.0.15 and up.

$h3 PL/Java 1.3.0 (18 June 2006)

This release is about type mapping and the creation of new types in PL/Java. An
extensive effort has gone into making the PL/Java type system extremely
flexible. Not only can you map arbitrary SQL data types to java classes. You can
also create new scalar types completely in Java. Read about the Changes in
version 1.3.

$h4 Changes

* A much improved type mapping system that will allow you to:

    * [Map any SQL type to a Java class][maptype]
    * [Create a Scalar UDT in Java][scalarudt]
    * [Map array and pseudo types][deftypemap]

[maptype]: https://github.com/tada/pljava/wiki/Mapping-an-sql-type-to-a-java-class
[scalarudt]: https://github.com/tada/pljava/wiki/Creating-a-scalar-udt-in-java
[deftypemap]: https://github.com/tada/pljava/wiki/Default-type-mapping

* Get the OID for a given relation ([feature request 1319][1319])
* Jar manifest included in the SQLJ Jar repository
    ([feature request 1525][1525])

$h4 Fixed bugs

* [Reconnect needed for jar manipulation to take effect][1531]
* [Backends hang with test suite][1504]
* [Keeps crashing while making a call to a function][1560]
* [Memory Leak in Statement.executeUpdate][1556]
* [jarowner incorrect after dump and reload][1506]
* [Missing JAR manifest][1525]
* [TZ adjustments for Date are incorrect][1547]
* [Functions returning sets leaks memory][1542]
* [drop lib prefix][1423]
* ["oid" column is not available in trigger's NEW/OLD ResultSet][1317]
* [fails to run with GCJ, too][1480]
* [Compile failure with 8.1.4][1558]
* [fails to build with GCJ][1479]
* [Record returning function cannot be called with different structures within one session][1440]
* [Cannot map function with complex return type to method that uses non primitive arguments][1551]
* [Get OID for given relation][1319]

[1531]: ${gborgbug}1531
[1504]: ${gborgbug}1504
[1560]: ${gborgbug}1560
[1556]: ${gborgbug}1556
[1506]: ${gborgbug}1506
[1525]: ${gborgbug}1525
[1547]: ${gborgbug}1547
[1542]: ${gborgbug}1542
[1423]: ${gborgbug}1423
[1317]: ${gborgbug}1317
[1480]: ${gborgbug}1480
[1558]: ${gborgbug}1558
[1479]: ${gborgbug}1479
[1440]: ${gborgbug}1440
[1551]: ${gborgbug}1551
[1319]: ${gborgbug}1319

$h3 PL/Java 1.2.0 (20 Nov 2005)

The PL/Java 1.2.0 release is primarily targeted at the new PostgreSQL 8.1 but
full support for 8.0.x is maintained. New features include support IN/OUT
parameters, improved meta-data handling, and better memory management.

$h3 PL/Java 1.1.0 (14 Apr 2005)

PL/Java 1.1.0 includes a lot of new features such as `DatabaseMetaData`,
`ResultSetMetaData`, language handlers for both trusted and untrusted language,
additional semantics for functions returning `SETOF`, and simple ObjectPooling.

$h3 PL/Java 1.0.1 (07 Feb 2005)

This release resolves a couple of important security issues. The most important
one is perhaps that PL/Java now is a trusted language. See [Security][] for more
info. Filip Hrbek, now member of the PL/Java project, contributed what was
needed to make this happen.

[Security]: https://github.com/tada/pljava/wiki/Security

$h3 PL/Java 1.0.0 (23 Jan 2005)

Today, after a long period of fine tuning, PL/Java 1.0.0 was finally released.
